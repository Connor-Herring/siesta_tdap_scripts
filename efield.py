import matplotlib.pyplot as plt
import numpy as np 
import math
from statistics import mean
import plotly.express as px
import plotly.graph_objects as go
import sys
import argparse

#####################PARAMETERS######################
G = 1 #gaussian coef
time_conversion = 0.04837 #converts hbar/Ry to fs
sigma = 150*time_conversion
H = 0 #heavy side coef
A = 0.1 #amplitude 
omega = .1838/time_conversion #angular frequency [units of Ry/hbar] --> convert to inverse fs
phi = 600 #shift onset
C = 0 #bias
Pi = 3.14159
t0 = 800*time_conversion #onset time
ntime = 3000
normalization_term = 1
is_normalized = False
t_step = 0.5 #hbar/Ry (defined in input.fdf)

if is_normalized:
	normalization_term = sigma*float(math.sqrt(2*Pi))
########################################################

#make matplotlib plot of efield based on params defined above
def plot_calculated_efield():
	E = [] #holds calculated e-field at each step 
	time = []

	for i in range(ntime):
		t =i*time_conversion*t_step
		t_diff = t- t0
		term1 = (G/(normalization_term))*math.exp(-((t-t0)**2)/(2*(sigma)**2)) + H*np.heaviside(t_diff, 1)
		term2 = (A*math.sin(omega*(t-t0) -phi) + C)
		if i <10:
			print('term1*term2 = ' + str(term1*term2))
		E.append(float(term1*term2))
		time.append(float(t))
		

	plt.rcParams.update({'mathtext.default':  'regular' })
	plt.rcParams['axes.linewidth'] = 1.0
	plt.rcParams.update({'font.size': 15})
	plt.rcParams.update({'mathtext.default':  'regular' })
	plt.plot(time, E, color='b', linewidth=1.7)
	plt.xlabel("Time (fs)")
	plt.ylabel("Electric Field (Ry/Bohr/e)")
	plt.show()

#returns the calculated external field at time t (fs)
def calculate_efield_at(Time):
	Time = float(Time)
	t_diff =Time - t0
	term1 = (G/(normalization_term))*math.exp(-((Time-t0)**2)/(2*(sigma)**2)) + H*np.heaviside(t_diff, 1)
	term2 = A*math.sin(omega*(Time-t0) -phi) + C
	efield = float(term1*term2)
	print(efield)
	return efield

#used to find the maximum value of the external field saved at the frequency of WFZs
def find_max_efield(num_wfz_files):
	efield_arr = []

	for i in range(num_wfz_files +1):
		time = (i/num_wfz_files)*ntime*time_conversion*t_step
		current_efield = calculate_efield_at(time)
		print(current_efield)
		efield_arr.append(current_efield)

	max_efield = max(efield_arr)
	max_index = efield_arr.index(max_efield)
	min_efield = min(efield_arr)
	min_index = efield_arr.index(min_efield)
	print('max efield: ' + str(max_efield) + ' at wfz: ' + str(max_index))
	print('min efield: ' + str(min_efield) + ' at wfz: ' + str(min_index))

#get efield values from out file generated by siesta (provide path to out file)
def get_efield(path):
	f = open(path + '/out', 'r')
	x_efield = []
	y_efield = []
	z_efield = []
	time = []

	Lines = f.readlines()
	for line in Lines:
		cut = line.split()
		if(len(cut)>1):
			if(cut[0] + cut[1] == 'TDfield:'):
				try:
					time.append(float(cut[6])*time_conversion) #conversion factor for hbar/Ry to fs
					x_efield.append(float(cut[2]))
					y_efield.append(float(cut[3]))
					z_efield.append(float(cut[4]))
				except:
					pass

	print(len(x_efield))
	return [time, x_efield, y_efield, z_efield]

#plot efield with plotly from out file generated by siesta
def plot_efield(path):
	data = get_efield(path)
	time = data[0]
	x_efield = data[1]
	y_efield = data[2]
	z_efield = data[3]

	fig = px.line(x=time, y=x_efield)
	fig.update_layout(
	    	xaxis_title="Time (fs)",
	    	yaxis_title="E-field X (Ry/Bohr/e)",
	    )
	fig.show()

	fig_y = px.line(x=time, y=y_efield)
	fig_y.update_layout(
	    	xaxis_title="Time (fs)",
	    	yaxis_title="E-field Y (Ry/Bohr/e)",
	    )
	fig_y.show()

	fig_z = px.line(x=time, y=z_efield)
	fig_z.update_layout(
	    	xaxis_title="Time (fs)",
	    	yaxis_title="E-field Z (Ry/Bohr/e)",
	    )
	fig_z.show()

#used to get average value of the external field over some time range
def average_value():
	start_time = 15 #fs
	end_time = 65
	efield_arr = []

	for i in range(start_time, end_time):
		value = abs(calculate_efield_at(i))
		print(value)
		efield_arr.append(value)

	avg_value = mean(efield_arr)
	print('avg: ' + str(avg_value))

def get_vector_potential_values(path):
	f = open(path + '/out', 'r')
	Atot = []
	jint = []
	jion = []
	je_ji = []
	tint_j = []
	Eext = []
	current_MD_step = 0
	current_Atot = 0
	current_jint = 0
	current_jion = 0
	current_je_ji = 0
	current_tint_j = 0
	current_Eext = 0
	Lines = f.readlines()

	for line in Lines:
		cut = line.split()
		if(len(cut)>1):

			if cut[0] =='Begin' and cut[1] =='MD':
				current_MD_step = cut[4]
				Atot.append(current_Atot)
				jint.append(current_jint)
				jion.append(current_jion)
				je_ji.append(current_je_ji)
				tint_j.append(current_tint_j)
				Eext.append(current_Eext)
			elif(cut[0] == 'XXX' and cut[1] =='Atot:'):
				current_Atot = cut[2]

			elif(cut[0] == 'XXX' and cut[1] =='jint:'):
				current_jint = cut[2]

			elif(cut[0] == 'XXX' and cut[1] =='jion:'):
				current_jion = cut[2]

			elif(cut[0] == 'XXX' and cut[1] =='je+ji:'):
				current_je_ji = cut[2]

			elif(cut[0] == 'XXX' and cut[1] =='tint_j:'):
				current_tint_j = cut[2]

			elif(cut[0] == 'XXX' and cut[1] =='Eext:'):
				current_Eext = cut[2]
		
	print('md setps: ' +str(current_MD_step))
	time = [i*.0242 for i in range(int(current_MD_step))]

	return [Atot, jint, jion, je_ji, tint_j, Eext, time]

def plot_vector_potential_values(path):
	data = get_vector_potential_values(path)
	time_fs = data[6]

	fig = px.line(x=time_fs, y=data[0])
	fig.update_layout(
	    	xaxis_title="Time (fs)",
	    	yaxis_title="Atot",
	    )
	fig.update_layout(autotypenumbers='convert types')
	fig.show()

	fig2 = px.line(x=time_fs, y=data[1])
	fig2.update_layout(
	    	xaxis_title="Time (fs)",
	    	yaxis_title="jint",
	    )
	fig2.update_layout(autotypenumbers='convert types')
	fig2.show()

	fig3 = px.line(x=time_fs, y=data[2])
	fig3.update_layout(
	    	xaxis_title="Time (fs)",
	    	yaxis_title="jion",
	    )
	fig3.update_layout(autotypenumbers='convert types')
	fig3.show()

	fig4 = px.line(x=time_fs, y=data[3])
	fig4.update_layout(
	    	xaxis_title="Time (fs)",
	    	yaxis_title="je+ji",
	    )
	fig4.update_layout(autotypenumbers='convert types')
	fig4.show()

	fig5 = px.line(x=time_fs, y=data[4])
	fig5.update_layout(
	    	xaxis_title="Time (fs)",
	    	yaxis_title="tint_j",
	    )
	fig5.update_layout(autotypenumbers='convert types')
	fig5.show()

	fig6 = px.line(x=time_fs, y=data[5])
	fig6.update_layout(
	    	xaxis_title="Time (fs)",
	    	yaxis_title="Eext (Ry/Bohr/e)",
	    )
	fig6.update_layout(autotypenumbers='convert types')
	fig6.show()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run a specific function with arguments.")
    parser.add_argument("function", type=str, help="Name of the function to run")
    parser.add_argument("args", nargs="*", help="Arguments to pass to the function")
    
    args = parser.parse_args()

    # Dynamically call the function with arguments
    if args.function in globals():
        globals()[args.function](*args.args)
    else:
        print(f"No such function: {args.function}")

